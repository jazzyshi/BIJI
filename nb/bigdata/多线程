线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。
synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为"互斥区"或"临界区"

分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的），
一个线程想要执行synchronized修饰的方法里的代码：
1 尝试获得锁
2 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，
而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题）

/**
 * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁，
 * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock），
 *
 * 两个对象，线程获得的就是两个不同的锁，他们互不干扰
 *
 * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。
 * @author alienware
 *
 */


/**
 * 对象锁的同步和异步问题
 *
 * 同步的概念就是共享，如果不是共享的资源就没有必要进行同步
 * 同步的概念是为了线程安全（原子性（同步）、可见性）
 * 异步的概念就是独立，相互之间不受任何的约束
 * 分析：
 * t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法
 * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步
 */


/**
 * 业务整体需要使用完整的synchronized，保持业务的原子性。
 * set/get都要sync才能保持整体一致性
 * @author alienware
 *
 */

/**
 * synchronized的重入
 * @author alienware
 *
 */
public class SyncDubbo1 {

	public synchronized void method1(){
		System.out.println("method1..");
		method2();
	}
	public synchronized void method2(){
		System.out.println("method2..");
		method3();
	}
	public synchronized void method3(){
		System.out.println("method3..");
	}
}


/**
 * synchronized的重入
 * 当一个线程得到了一个对象的锁后，再次请求时是可以再次获得该对象的锁
/


/**
 * 锁对象的改变问题
 * 锁对象改变，那么持有的锁就不同
 * @author alienware
 *
 */


/**
 * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况
 * @author alienware

使用synchronized代码块加锁,比较灵活,减小锁的粒度，提高性能,注意String常量池的缓存功能

//多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性
private static AtomicInteger count = new AtomicInteger(0);
/**synchronized*/
public synchronized int multiAdd(){
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    count.addAndGet(1);
    count.addAndGet(2);
    count.addAndGet(3);
    count.addAndGet(4); //+10
    return count.get();
}


/**
 * 加volatile让变量在多个线程间可见性，只有可见性没有原子性
 * 线程工作时会在jvm中开辟一个新的内存空间，创建主内存对象的引用
 * 加volatile让主内存变量改变时通知线程读取主内存中的变量
 * 性能比synchronized性能强，但是无法代替其同步功能
 */

/**
 * volatile关键字不具备synchronized关键字的原子性（同步）
 * 要实现原子性建议使用atomic类的系列对象，支持原子性操作
 * @author alienware
 *
 */

wait notfiy 方法，wait释放锁，notfiy不释放锁（直到执行完才释放锁）
当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用

/**
 * ThreadLocal:线程局部变量,是一种多线程间并发访问变量的解决方案。
 * 其完全不提供锁，使用空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全。
 * 从性能上说，不具备绝对的优势，在并发不是很高的时候，加锁的性能会更好。
 public static ThreadLocal<String> th = new ThreadLocal<String>();
 */


/**
 * 单例模式,最常见的就是饥饿模式和懒汉模式，一个直接实例化对象，一个在调用的时候进行实例化对象
 *
 * 在多线程模式下，考虑到性能和线程安全问题，我们一般选择
 * double check instance（双重判断） 和 static inner class（静态内部类）
 */

/**
 * 多线程使用Vector或者HashTable的示例（简单线程同步问题）
 *
 * 同步类容器：如古老的Vector、HashTable,其实都是由JDK的Collections.synchronized等工厂方法实现
 * ，其底层无非是用synchronized关键字对每个公用方法都进行同步，使得每次只能有一个线程访问容器的状态
 *
 * 同步类容器都是线程安全的。
 * 但是复合查询（迭代-反复访问元素，遍历完容器中所有元素）、
 * 跳转（根据指定的顺序找到当前元素的下一个元素）、
 * 以及条件运算。这些复合操作在多线程并发修改容器时，可能会出现意外的行为，
 * 最经典的是ConcurrentModificationException,原因是容器迭代的过程中，被并发的修改了内容
 */

 /**
  * ConcurrentMap接口下两个主要实现：1.ConcurrentHashMap 2..ConcurrentSkipListMap(支持并发排序功能，参考treemap)
  *
  * HashTable - > ConcurrentHashMap（把大的容器切分成16分小的hashtable，减小锁粒度，减少锁竞争
  * ,并且大多共享变量使用volatile关键字声明，目的是第一时间获取修改的内容，性能非常好）
  */

/**
 * copy-on-write 是一种用于程序设计的优化策略
 * JDK的COW容器有两种CopyOnWriteArrayList、CopyOnWriteArraySet
 * COW容器即写时复制的容器。通俗的讲：添加时先拷贝，复制一个新的容器，新的容器进行添加元素，添加完然后引用指向新容器
 * 好处：可以并发的读，而不需要加锁，应为当前容器不会添加任何元素。添加元素的操作在拷贝的容器上执行
 * 读写分离的思想
 */

/**
* peek获取后不删除
* poll获取后删除
* LinkedBlockingDeque<String> dq = new LinkedBlockingDeque<String>(10);
*/


/**
 * 在并发队列上JDK提供两套实现。
 * 1.ConcurrentLinkedQueue为代表的高性能队列，无阻塞，值不允许null
 * 2.BlockingQueue接口为代表的阻塞队列，他的实现队列（
 *       a.ArrayBlockingQueue
 *          基于数组的阻塞队列实现，内部实现读写分离，意味着生产着和消费者不能完全并行
 *          长度需要定义,可以指定先进先出后者后进先出，也叫有界队列
 *       b.LinkedBlockingQueue
 *       	基于链表实现的阻塞队列,能够高效的处理并发，是应为内部实现了分离锁（读写分离两个锁），
 *          从而实现生产者和消费者操作的完全并行运行。他是一个无界队列
 *       c.SynchronousQueue
 *			一个没有缓冲的队列，生产者产生的数据直接会被消费者获取并消费
 *       d.DelayQueue
 *         带有延迟时间的queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取该队列。
 *         DelayQueue的元素必须实现Delayed接口，无界队列
 *         应用场景很多：对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等
 *       e.PriorityBlocingQueue
 *       	基于优先级的的阻塞队列（优先级通过构造函数传入的Compator对象来决定，
 *       	也就是说传人的对象必须实现Comparable接口），内部控制线程同步的锁采用公平锁，无界队列
 *
 *  1，2 都继承Queue
 */

/**
 * 1.并发编程设计模式-Future模式
 *  类似于商品订单：提交订单，就可以在家里等待商品送货上门
 *  类似Ajax请求
 * 2.并发编程设计模式-MyMaster-worker模式
 * 3.生产者消费者模式
 */

 /**
  * 线程框架Executor:为了更好的控制线程。在java.util.concurrent包中
  * 多任务执行框架
  * 重要类：Executors 扮演线程工厂的角色
  * 1.newFixedThreadPool(),该方法发回一个固定数量的线程池，
  *   若线程池空闲立即执行，若没有则会被暂缓在一个任务队列中等待有空闲的线程执行
  * 2.newSingleThreadExecuter()，创建一个线程的线程池
  *   若线程池空闲立即执行，若没有则会被暂缓在一个任务队列中等待有空闲的线程执行
  * 3.newCachedThreadPool(),可根据实际情况调整线程池的个数，
  *   每一个空闲的线程会在默认60s后自动回收
  * 4.newScheduledThreadPool()方法，该方法返回SchededExecutorService对象，可以指定线程池的大小
  *   队列是elayedQueueD，可以实现定时功能
  */

/**
 * 在使用有界队列时，若有新的任务需要执行，如果线程池实际线程数小于corePoolSize，则优先创建线程，
 * 若大于corePoolSize，则会将任务加入队列，
 * 若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程，
 * 若线程数大于maximumPoolSize，则执行拒绝策略。或其他自定义方式。
 *
   ThreadPoolExecutor pool = new ThreadPoolExecutor(
 				1, 				//coreSize
 				2, 				//MaxSize
 				60, 			//60
 				TimeUnit.SECONDS,
 				new ArrayBlockingQueue<Runnable>(3)			//指定一种队列 （有界队列）
 				//new LinkedBlockingQueue<Runnable>()
 				, new MyRejected()
 				//, new DiscardOldestPolicy()
 				);
 */

 /**
  * Concurrent.util常用类CountDownLatch
  * CountDownLatch 经常用于监听某些初始化操作，
  * 等初始化执行完毕后，通知主线程继续工作
  * 初始化数字是几，就要通知几次countDown.countDown()
  */

  /**
   * 业务需求3：两个线程，在同一个点（阻塞点）交换数据
   *  绑架案一手交钱一手交货
   *  Exchanger 两个线程交互数据
   *交换器，交换String类型数据
     final Exchanger<String> ec = new Exchanger<>();


/**
 *  Concurrent.util常用类CyclicBarrier
 * 只有线程都准备好后，才一起出发，只要有一个没准备好，大家都等待
 /**
  * CyclicBarrier可循环障碍物
  * 业务需求2：吃饭，各自从家里到聚餐地点，全部到齐之后，才开始一起吃东西（同步点）
    加入人没到齐，到的人只能等到那里（阻塞），直到所有人都到齐后才开始 吃饭
    吃完饭之后，到步步高广场结合，一起打游戏
    多线程合并结果
  * Created by jazzyshi on 2018/10/12.
  */
 */
public class UseCyclicBarrier {

	static class Runner implements Runnable {
	    private CyclicBarrier barrier;
	    private String name;

	    public Runner(CyclicBarrier barrier, String name) {
	        this.barrier = barrier;
	        this.name = name;
	    }
	    @Override
	    public void run() {
	        try {
	            Thread.sleep(1000 * (new Random()).nextInt(5));
	            System.out.println(name + " 准备OK.");
	            barrier.await();
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        } catch (BrokenBarrierException e) {
	            e.printStackTrace();
	        }
	        System.out.println(name + " Go!!");
	    }
	}

    public static void main(String[] args) throws IOException, InterruptedException {
        CyclicBarrier barrier = new CyclicBarrier(3);  // 3
        ExecutorService executor = Executors.newFixedThreadPool(3);

        executor.submit(new Thread(new Runner(barrier, "zhangsan")));
        executor.submit(new Thread(new Runner(barrier, "lisi")));
        executor.submit(new Thread(new Runner(barrier, "wangwu")));

        executor.shutdown();
    }

}

/**
 * Concurrent.util常用类Future和Callable
 * Future模式非常适合处理很耗时的业务逻辑，可以有效的减少系统的响应时间，提高系统的吞吐量
 */
public class UseFuture implements Callable<String>{
	private String para;

	public UseFuture(String para){
		this.para = para;
	}

	/**
	 * 这里是真实的业务逻辑，其执行可能很慢
	 */
	@Override
	public String call() throws Exception {
		//模拟执行耗时
		Thread.sleep(5000);
		String result = this.para + "处理完成";
		return result;
	}

	//主控制函数
	public static void main(String[] args) throws Exception {
		String queryStr = "query";
		//构造FutureTask，并且传入需要真正进行业务逻辑处理的类,该类一定是实现了Callable接口的类
		FutureTask<String> future1 = new FutureTask<String>(new UseFuture(queryStr));

		FutureTask<String> future2 = new FutureTask<String>(new UseFuture(queryStr));
		//创建一个固定线程的线程池且线程数为1,
		ExecutorService executor = Executors.newFixedThreadPool(2);
		//这里提交任务future,则开启线程执行RealData的call()方法执行
		//submit和execute的区别： 第一点是submit可以传入实现Callable接口的实例对象， 第二点是submit方法有返回值

		Future f1 = executor.submit(future1);		//单独启动一个线程去执行的
		Future f2 = executor.submit(future2);
		System.out.println("请求完毕");

		try {
			//这里可以做额外的数据操作，也就是主程序执行其他业务逻辑
			System.out.println("处理其它实际的业务逻辑...");
			Thread.sleep(1000);
		} catch (Exception e) {
			e.printStackTrace();
		}
		//调用获取数据方法,如果call()方法没有执行完成,则依然会进行等待
		System.out.println("数据：" + future1.get());
		System.out.println("数据：" + future2.get());

		executor.shutdown();
	}
}

/**
 * JAVA限流
 * Semaphore可以控制系统的流量：拿到信号量的线程可以进入，否则就等到。
 * 通过acquire()和release()获取和释放访问许可
 */
public class UseSemaphore {

    public static void main(String[] args) {
        // 线程池
        ExecutorService exec = Executors.newCachedThreadPool();
        // 只能5个线程同时访问
        final Semaphore semp = new Semaphore(5);
        // 模拟20个客户端访问
        for (int index = 0; index < 20; index++) {
            final int NO = index;
            System.out.println("NO="+NO);
            Runnable run = new Runnable() {
                public void run() {
                    try {
                        // 获取许可
                        semp.acquire();
                        System.out.println("Accessing: " + NO);
                        //模拟实际业务逻辑
                        Thread.sleep(10000);
                        // 访问完后，释放
                        semp.release();
                    } catch (InterruptedException e) {
                    }
                }
            };
            exec.execute(run);
        }

        try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

        System.out.println("大小"+semp.getQueueLength());



        // 退出线程池
        exec.shutdown();
    }

}

/**
 * 在java多线程中，可以用synchronized关键字实现线程间的同步互斥工作，
 * 其实还有一个更优秀的机制去完成“同步互斥”工作，他就是Lock对象。
 * 主要学习两种锁：重入锁和读写锁，他们比synchronized更加强大，并且有嗅探锁定、多路分支等功能
 *  private Lock lock = new ReentrantLock();lock.lock();lock.unlock();
 * 初始化时可以有个参数 公平锁还是非公平锁
 * lock里的方法：自己尝试
 *
  * 在使用Lock的时候。可以使用新的等待/通知类-Condition
  * 这个Condition一定是针对具体某一把锁的
  *  private Lock lock = new ReentrantLock();
  *	private Condition condition = lock.newCondition();condition.await();condition.signal();
 *
 可以通过lock对象创建多个condition
 private ReentrantLock lock = new ReentrantLock();
 private Condition c1 = lock.newCondition();
 private Condition c2 = lock.newCondition();
  *
  * lock.getHoldCount()方法：只能在当前调用线程内部使用，不能再其他线程中使用
  * 那么我可以在m1方法里去调用m2方法，同时m1方法和m2方法都持有lock锁定即可 测试结果holdCount数递增
  *
  */

/**
 * ReentrantReadWriteLock-读写锁，其核心就是实现读写分离的锁。
 * 在高并发访问下，尤其是读多写少的情况下，性能远高于重入锁
 * （为什么？因为synchronized和ReentranLock同一时间只能有一个线程访问被锁定的代码）
 * 而读写锁则不同，其本质时分成两个锁。在读锁下，多个线程可以并发的进行访问，但是在写锁的时候，只能有一个一个顺序访问
 *
 * 口诀：读读共享、写写互斥、读写互斥

    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
 	private ReadLock readLock = rwLock.readLock();
 	private WriteLock writeLock = rwLock.writeLock();
 */